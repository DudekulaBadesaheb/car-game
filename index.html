<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Full 3D Car Game — Forest / City / Desert + Controls</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        background: #072022;
        color: #fff;
        font-family: Inter, system-ui, Segoe UI, Roboto, Arial;
      }
      #gameContainer {
        position: fixed;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        display: block;
      }
      canvas {
        display: block;
      }
      /* HUD */
      #hud {
        position: fixed;
        left: 12px;
        top: 12px;
        z-index: 60;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.28),
          rgba(0, 0, 0, 0.12)
        );
        padding: 10px 12px;
        border-radius: 10px;
        backdrop-filter: blur(6px);
        font-size: 14px;
      }
      #minimapWrapper {
        position: fixed;
        right: 12px;
        top: 12px;
        z-index: 50;
        width: 260px;
        height: 160px;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
        background: linear-gradient(180deg, #05171b, #021016);
      }
      #minimap {
        width: 100%;
        height: 100%;
        display: block;
      }
      /* Shop overlay */
      #shopOverlay {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 880px;
        max-width: 96%;
        height: 560px;
        max-height: 92%;
        background: linear-gradient(
          180deg,
          rgba(6, 12, 18, 0.98),
          rgba(3, 6, 10, 0.98)
        );
        border-radius: 14px;
        z-index: 100;
        display: none;
        padding: 18px;
        box-shadow: 0 30px 80px rgba(0, 0, 0, 0.7);
      }
      .car-card {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.02);
        margin-bottom: 10px;
      }
      .btn {
        padding: 8px 14px;
        border-radius: 10px;
        background: #0d6efd;
        color: #fff;
        border: none;
        cursor: pointer;
      }
      #footerHints {
        position: fixed;
        left: 12px;
        bottom: 12px;
        z-index: 40;
        font-size: 13px;
        color: #cfe;
      }
      /* On-screen manual control buttons */
      .control-pad {
        position: fixed;
        right: 12px;
        bottom: 12px;
        z-index: 80;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .control-row {
        display: flex;
        gap: 8px;
      }
      .ctl-btn {
        width: 64px;
        height: 64px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.04);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.04);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.5);
        cursor: pointer;
        user-select: none;
      }
      .ctl-btn:active {
        transform: translateY(2px);
      }
      /* Brake button special */
      .brake {
        background: linear-gradient(180deg, #6b0b0b, #3c0202);
      }
      /* mobile joystick (left) */
      #joystick {
        position: fixed;
        left: 12px;
        bottom: 12px;
        width: 140px;
        height: 140px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.02);
        display: none;
        z-index: 80;
      }
      #joyInner {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.04);
      }
      @media (max-width: 900px) {
        #joystick {
          display: block;
        }
      }
      /* Level complete overlay */
      #levelCompleteOverlay {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 200;
        background: linear-gradient(
          180deg,
          rgba(2, 8, 10, 0.98),
          rgba(8, 14, 18, 0.98)
        );
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 30px 80px rgba(0, 0, 0, 0.7);
        display: none;
        min-width: 360px;
        text-align: center;
      }
      #levelCompleteOverlay h2 {
        margin: 0 0 8px 0;
      }
      #levelCompleteOverlay p {
        opacity: 0.9;
      }
      #levelCompleteOverlay .actions {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 12px;
      }
      .muted {
        opacity: 0.8;
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <div id="gameContainer"></div>
    <div id="hud">
      <div>
        Level: <span id="levelLabel">1</span> / <span id="totalLevels">20</span>
      </div>
      <div>Coins: <span id="coinsLabel">0</span></div>
      <div>Time: <span id="timeLabel">0.00</span>s</div>
    </div>
    <div id="minimapWrapper"><canvas id="minimap"></canvas></div>
    <div id="shopOverlay" aria-hidden="true">
      <button
        id="closeShop"
        class="btn"
        style="position: absolute; right: 14px; top: 12px"
      >
        Close
      </button>
      <h2>Garage — Buy / Select Cars</h2>
      <div
        style="display: flex; gap: 12px; height: 100%; align-items: flex-start"
      >
        <div style="flex: 1; overflow: auto; padding-right: 8px">
          <div id="carsList"></div>
        </div>
        <div style="width: 260px">
          <div
            style="
              background: rgba(255, 255, 255, 0.02);
              padding: 12px;
              border-radius: 8px;
            "
          >
            <h4>Your Coins</h4>
            <div style="font-size: 20px" id="shopCoins">0</div>
            <hr style="opacity: 0.08; border-color: #fff" />
            <div>
              <strong>Selected:</strong> <span id="shopSelected">None</span>
            </div>
            <div style="height: 12px"></div>
            <button id="buyBtn" class="btn" style="width: 100%">
              Buy / Select
            </button>
          </div>
        </div>
      </div>
    </div>
    <div id="joystick"><div id="joyInner"></div></div>

    <div class="control-pad" id="controls">
      <div class="control-row">
        <div class="ctl-btn" id="btnLeft">◄</div>
        <div class="ctl-btn" id="btnForward">▲</div>
        <div class="ctl-btn" id="btnRight">►</div>
      </div>
      <div class="control-row">
        <div class="ctl-btn brake" id="btnBrake">Brake</div>
        <div class="ctl-btn" id="btnBoost">Boost</div>
        <div class="ctl-btn" id="btnShop">Shop</div>
      </div>
    </div>

    <div id="levelCompleteOverlay">
      <h2 id="completeTitle">Level Complete</h2>
      <p id="completeMsg">
        You finished level <span id="completeLevel">1</span>!
      </p>
      <div class="muted">Coins earned: <span id="completeCoins">0</span></div>
      <div class="actions">
        <button id="nextLevelBtn" class="btn">Next Level</button>
        <button id="skipTo3Btn" class="btn">Go to Level 3</button>
        <button id="closeOverlayBtn" class="btn">Close</button>
      </div>
    </div>

    <div id="footerHints">
      Controls: W/A/S/D or ←→↑↓ • Use on-screen buttons (bottom-right) on touch
      • Shift=Boost • R=Restart • N=Next • M=Toggle minimap • S=Shop
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script>
      // --- Setup renderer & scene ---
      const container = document.getElementById("gameContainer");
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x071017);
      scene.fog = new THREE.FogExp2(0x071017, 0.0009);

      const camera = new THREE.PerspectiveCamera(
        65,
        window.innerWidth / window.innerHeight,
        0.1,
        5000
      );
      camera.position.set(0, 6, -14);

      // Lights
      const hemi = new THREE.HemisphereLight(0xddeeff, 0x041018, 0.6);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(120, 200, 120);
      dir.castShadow = true;
      dir.shadow.mapSize.width = dir.shadow.mapSize.height = 2048;
      scene.add(dir);
      const amb = new THREE.AmbientLight(0x223344, 0.35);
      scene.add(amb);

      // Ground
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x264b3b,
        roughness: 0.95,
      });
      const groundGeo = new THREE.PlaneGeometry(8000, 8000);
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // --- World generation: track, obstacles, coins, environments ---
      const TOTAL_LEVELS = 20;
      let levelIndex = 1;
      function generateTrack(level) {
        const segments = 6 + Math.floor(level * 0.6);
        const path = [];
        let x = -200;
        let z = 0;
        for (let i = 0; i < segments; i++) {
          x += 160 + Math.random() * 160;
          z += (Math.random() - 0.5) * 300;
          path.push(new THREE.Vector3(x, 0, z));
        }
        // obstacles
        const obstacles = [];
        const obsCount = 4 + Math.floor(level * 0.6);
        for (let o = 0; o < obsCount; o++) {
          const wp = path[Math.floor(Math.random() * path.length)];
          obstacles.push({
            pos: new THREE.Vector3(
              wp.x + (Math.random() - 0.5) * 120,
              1.0,
              wp.z + (Math.random() - 0.5) * 120
            ),
            size: 14 + Math.random() * 36,
          });
        }
        // coins
        const coins = [];
        const coinCount = 8 + Math.floor(level * 0.9);
        for (let c = 0; c < coinCount; c++) {
          const idx = Math.floor(Math.random() * (path.length - 1));
          const a = path[idx];
          const b = path[idx + 1] || a;
          const t = Math.random();
          const cx = a.x + (b.x - a.x) * t + (Math.random() - 0.5) * 60;
          const cz = a.z + (b.z - a.z) * t + (Math.random() - 0.5) * 40;
          coins.push(new THREE.Vector3(cx, 1.6, cz));
        }
        // environment zones: scatter trees to left area, buildings to center-right, dunes far right
        const trees = [];
        const buildings = [];
        const dunes = [];
        for (let i = 0; i < 120; i++) {
          const rx = -500 + Math.random() * 800;
          const rz = -400 + Math.random() * 1200;
          if (rx < -50) trees.push(new THREE.Vector3(rx, 0, rz));
          else if (rx < 200) buildings.push(new THREE.Vector3(rx, 0, rz));
          else dunes.push(new THREE.Vector3(rx, 0, rz));
        }
        // finish point at the last path point
        const finish = path[path.length - 1]
          .clone()
          .add(new THREE.Vector3(140, 0, 0));
        return { path, obstacles, coins, trees, buildings, dunes, finish };
      }
      let world = generateTrack(levelIndex);

      // --- Render track as tube ---
      let pathMesh;
      function buildPath(path) {
        if (pathMesh) {
          scene.remove(pathMesh);
          pathMesh.geometry.dispose();
        }
        const points = [new THREE.Vector3(-260, 0, 0)]
          .concat(path)
          .concat([
            new THREE.Vector3(
              path[path.length - 1].x + 160,
              0,
              path[path.length - 1].z
            ),
          ]);
        const curve = new THREE.CatmullRomCurve3(points);
        const geo = new THREE.TubeGeometry(curve, 400, 36, 12, false);
        const mat = new THREE.MeshStandardMaterial({
          color: 0x2e3336,
          roughness: 0.9,
        });
        pathMesh = new THREE.Mesh(geo, mat);
        pathMesh.receiveShadow = true;
        scene.add(pathMesh);
      }
      buildPath(world.path);

      // --- Entities groups ---
      const obstaclesGroup = new THREE.Group();
      scene.add(obstaclesGroup);
      const coinsGroup = new THREE.Group();
      scene.add(coinsGroup);
      const treesGroup = new THREE.Group();
      scene.add(treesGroup);
      const buildingsGroup = new THREE.Group();
      scene.add(buildingsGroup);
      const dunesGroup = new THREE.Group();
      scene.add(dunesGroup);

      // --- Populate environment ---
      function addTree(pos) {
        const trunk = new THREE.CylinderGeometry(0.8, 0.8, 4, 8);
        const trunkM = new THREE.MeshStandardMaterial({ color: 0x6b3b1f });
        const t = new THREE.Mesh(trunk, trunkM);
        t.position.set(pos.x, 2, pos.z);
        t.castShadow = true;
        const foliage = new THREE.ConeGeometry(
          3.5 + Math.random() * 2,
          8 + Math.random() * 3,
          8
        );
        const fM = new THREE.MeshStandardMaterial({ color: 0x2fbf6c });
        const f = new THREE.Mesh(foliage, fM);
        f.position.set(pos.x, 6, pos.z);
        f.castShadow = true;
        treesGroup.add(t);
        treesGroup.add(f);
      }
      function addBuilding(pos) {
        const h = 10 + Math.random() * 40;
        const w = 8 + Math.random() * 24;
        const d = 8 + Math.random() * 24;
        const g = new THREE.BoxGeometry(w, h, d);
        const m = new THREE.MeshStandardMaterial({
          color: 0x222a33,
          roughness: 0.8,
        });
        const b = new THREE.Mesh(g, m);
        b.position.set(pos.x, h / 2, pos.z);
        b.castShadow = true;
        buildingsGroup.add(b);
      }
      function addDune(pos) {
        const g = new THREE.BoxGeometry(
          20 + Math.random() * 30,
          4 + Math.random() * 6,
          12 + Math.random() * 30
        );
        const m = new THREE.MeshStandardMaterial({
          color: 0xd6c094,
          roughness: 1,
        });
        const d = new THREE.Mesh(g, m);
        d.position.set(pos.x, 2, pos.z);
        d.castShadow = false;
        dunesGroup.add(d);
      }

      function populateEnvironment() {
        treesGroup.clear();
        buildingsGroup.clear();
        dunesGroup.clear();
        for (const t of world.trees) {
          addTree(t);
        }
        for (const b of world.buildings) {
          addBuilding(b);
        }
        for (const d of world.dunes) {
          addDune(d);
        }
      }

      // --- Obstacles & coins populate ---
      function populateEntities() {
        // obstacles
        obstaclesGroup.clear();
        coinsGroup.clear();
        for (const o of world.obstacles) {
          const g = new THREE.BoxGeometry(o.size, o.size, o.size);
          const m = new THREE.MeshStandardMaterial({ color: 0x8b2e2e });
          const mesh = new THREE.Mesh(g, m);
          mesh.position.copy(o.pos);
          mesh.castShadow = true;
          obstaclesGroup.add(mesh);
        }
        for (const cp of world.coins) {
          const g = new THREE.CylinderGeometry(4, 4, 1.6, 18);
          const m = new THREE.MeshStandardMaterial({
            color: 0xffd54f,
            metalness: 0.9,
            emissive: 0xffb84d,
            emissiveIntensity: 0.7,
          });
          const mesh = new THREE.Mesh(g, m);
          mesh.position.copy(cp);
          mesh.rotation.x = Math.PI / 2;
          mesh.castShadow = true;
          coinsGroup.add(mesh);
        }
        // finish marker
        const finishGeom = new THREE.BoxGeometry(18, 2, 18);
        const finishMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const finishMesh = new THREE.Mesh(finishGeom, finishMat);
        finishMesh.position.copy(world.finish).add(new THREE.Vector3(0, 1, 0));
        scene.add(finishMesh);
        world.finishMesh = finishMesh;
      }
      populateEntities();
      populateEnvironment();

      // --- Car mesh and player ---
      function makeCar(color = 0x2196f3) {
        const grp = new THREE.Group();
        const body = new THREE.BoxGeometry(7.2, 2.6, 13.2);
        const mat = new THREE.MeshStandardMaterial({
          color,
          metalness: 0.2,
          roughness: 0.35,
        });
        const mesh = new THREE.Mesh(body, mat);
        mesh.position.y = 1.7;
        mesh.castShadow = true;
        grp.add(mesh);
        const roof = new THREE.BoxGeometry(4.2, 0.9, 4.6);
        const roofM = new THREE.MeshStandardMaterial({
          color: 0x061424,
          opacity: 0.7,
          transparent: true,
        });
        const roofMesh = new THREE.Mesh(roof, roofM);
        roofMesh.position.set(0, 2.4, -0.4);
        grp.add(roofMesh);
        const wheelGeo = new THREE.CylinderGeometry(1.3, 1.3, 0.8, 16);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x0b0b0b });
        const wheelPositions = [
          [-3.2, 0.6, 5.2],
          [3.2, 0.6, 5.2],
          [-3.2, 0.6, -5.2],
          [3.2, 0.6, -5.2],
        ];
        const wheels = [];
        for (const p of wheelPositions) {
          const w = new THREE.Mesh(wheelGeo, wheelMat);
          w.rotation.z = Math.PI / 2;
          w.position.set(p[0], p[1], p[2]);
          w.castShadow = true;
          grp.add(w);
          wheels.push(w);
        }
        grp.userData.wheels = wheels;
        return grp;
      }
      const player = { mesh: makeCar(0x2196f3), speed: 0, angle: 0, coins: 0 };
      player.mesh.position.set(world.path[0].x - 60, 0, world.path[0].z);
      player.mesh.scale.set(1.4, 1.4, 1.4);
      scene.add(player.mesh);

      // --- Camera follow ---
      function updateCamera() {
        const pos = player.mesh.position.clone();
        const behind = new THREE.Vector3(
          Math.sin(player.angle) * -1,
          0,
          Math.cos(player.angle) * -1
        ).multiplyScalar(16);
        const desired = pos.clone().add(behind).add(new THREE.Vector3(0, 6, 0));
        camera.position.lerp(desired, 0.08);
        camera.lookAt(pos.clone().add(new THREE.Vector3(0, 2.4, 0)));
      }

      // --- Minimap ---
      const minican = document.getElementById("minimap");
      const mmRenderer = new THREE.WebGLRenderer({
        antialias: false,
        alpha: true,
        canvas: minican,
      });
      mmRenderer.setSize(260, 160);
      const mmCamera = new THREE.OrthographicCamera(
        -220,
        220,
        140,
        -140,
        -1000,
        1000
      );
      mmCamera.up.set(0, 0, -1);
      mmCamera.position.set(0, 400, 0);
      mmCamera.lookAt(0, 0, 0);

      // --- Save / Shop ---
      const STORAGE = "full3d_game_save_v2";
      let save = { coins: 0, owned: [0], selected: 0 };
      try {
        const s = localStorage.getItem(STORAGE);
        if (s) save = JSON.parse(s);
      } catch (e) {}
      function saveGame() {
        localStorage.setItem(STORAGE, JSON.stringify(save));
        updateCoinsUI();
      }
      function updateCoinsUI() {
        document.getElementById("coinsLabel").innerText = save.coins || 0;
        document.getElementById("shopCoins").innerText = save.coins || 0;
      }
      updateCoinsUI();

      // --- Car catalog ---
      const CAR_CATALOG = [
        { id: 0, name: "Starter", color: 0x2196f3, price: 0 },
        { id: 1, name: "Crimson", color: 0xff3b3b, price: 80 },
        { id: 2, name: "Verdant", color: 0x4caf50, price: 160 },
        { id: 3, name: "Shadow", color: 0x111827, price: 320 },
        { id: 4, name: "Gold", color: 0xffd54f, price: 640 },
      ];
      function refreshShop() {
        const list = document.getElementById("carsList");
        list.innerHTML = "";
        for (const c of CAR_CATALOG) {
          const div = document.createElement("div");
          div.className = "car-card";
          div.innerHTML = `<div style="width:68px;height:46px;border-radius:8px;background:#07191b;display:flex;align-items:center;justify-content:center"><div style="width:48px;height:28px;background:${
            "#" + c.color.toString(16).padStart(6, "0")
          };border-radius:6px"></div></div><div style="flex:1"><div style="font-weight:600">${
            c.name
          }</div><div style="opacity:.7;font-size:13px">Price: ${
            c.price
          } ✪</div></div>`;
          div.dataset.id = c.id;
          div.addEventListener("click", () => {
            document
              .querySelectorAll(".car-card")
              .forEach((x) => (x.style.outline = "none"));
            div.style.outline = "2px solid rgba(255,255,255,0.06)";
            selectedShopCar = c.id;
            document.getElementById("shopSelected").innerText = c.name;
          });
          list.appendChild(div);
        }
        selectedShopCar = save.selected || 0;
        document.getElementById("shopSelected").innerText = CAR_CATALOG.find(
          (x) => x.id === selectedShopCar
        ).name;
      }
      let selectedShopCar = save.selected || 0;
      refreshShop();
      document.getElementById("buyBtn").addEventListener("click", () => {
        const car = CAR_CATALOG.find((x) => x.id === selectedShopCar);
        if (!car) return;
        if ((save.owned || []).includes(car.id)) {
          save.selected = car.id;
          applyCar(car.id);
          saveGame();
          alert("Selected " + car.name);
        } else {
          if ((save.coins || 0) >= car.price) {
            save.coins -= car.price;
            save.owned = save.owned || [];
            save.owned.push(car.id);
            save.selected = car.id;
            applyCar(car.id);
            saveGame();
            alert("Purchased " + car.name);
          } else alert("Not enough coins");
        }
        refreshShop();
      });

      document.getElementById("closeShop").addEventListener("click", () => {
        document.getElementById("shopOverlay").style.display = "none";
      });

      function applyCar(id) {
        const c = CAR_CATALOG.find((x) => x.id === id) || CAR_CATALOG[0];
        scene.remove(player.mesh);
        player.mesh = makeCar(c.color);
        player.mesh.scale.set(1.4, 1.4, 1.4);
        player.mesh.position.set(world.path[0].x - 60, 0, world.path[0].z);
        scene.add(player.mesh);
      }
      applyCar(save.selected || 0);

      // --- Controls (keyboard + on-screen) ---
      const controlState = {
        left: false,
        right: false,
        forward: false,
        brake: false,
        boost: false,
      };
      window.addEventListener("keydown", (e) => {
        const k = e.key.toLowerCase();
        if (k === "arrowleft" || k === "a") controlState.left = true;
        if (k === "arrowright" || k === "d") controlState.right = true;
        if (k === "arrowup" || k === "w") controlState.forward = true;
        if (k === "arrowdown" || k === "s") controlState.brake = true;
        if (k === "shift") controlState.boost = true;
        if (k === "m") {
          document.getElementById("minimapWrapper").style.display =
            document.getElementById("minimapWrapper").style.display === "none"
              ? "block"
              : "none";
        }
        if (k === "s") {
          document.getElementById("shopOverlay").style.display = "block";
          refreshShop();
        }
        if (k === "r") {
          restart();
        }
        if (k === "n") {
          nextLevel();
        }
      });
      window.addEventListener("keyup", (e) => {
        const k = e.key.toLowerCase();
        if (k === "arrowleft" || k === "a") controlState.left = false;
        if (k === "arrowright" || k === "d") controlState.right = false;
        if (k === "arrowup" || k === "w") controlState.forward = false;
        if (k === "arrowdown" || k === "s") controlState.brake = false;
        if (k === "shift") controlState.boost = false;
      });

      // on-screen buttons
      function bindBtn(id, flag) {
        const el = document.getElementById(id);
        el.addEventListener("pointerdown", () => {
          controlState[flag] = true;
          el.classList.add("active");
        });
        el.addEventListener("pointerup", () => {
          controlState[flag] = false;
          el.classList.remove("active");
        });
        el.addEventListener("pointerleave", () => {
          controlState[flag] = false;
          el.classList.remove("active");
        });
      }
      bindBtn("btnLeft", "left");
      bindBtn("btnRight", "right");
      bindBtn("btnForward", "forward");
      bindBtn("btnBrake", "brake");
      bindBtn("btnBoost", "boost");
      document.getElementById("btnShop").addEventListener("click", () => {
        document.getElementById("shopOverlay").style.display = "block";
        refreshShop();
      });

      // Joystick for mobile
      const joy = document.getElementById("joystick");
      const joyInner = document.getElementById("joyInner");
      let joystickActive = false,
        joyX = 0,
        joyY = 0;
      function joyStart(e) {
        joystickActive = true;
      }
      function joyMove(e) {
        if (!joystickActive) return;
        const t = e.touches ? e.touches[0] : e;
        const rect = joy.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const dx = Math.max(
          -1,
          Math.min(1, (t.clientX - cx) / (rect.width / 2))
        );
        const dy = Math.max(
          -1,
          Math.min(1, (t.clientY - cy) / (rect.height / 2))
        );
        joyInner.style.transform = `translate(${dx * 30}px, ${dy * 30}px)`;
        joyX = dx;
        joyY = dy;
        controlState.left = dx < -0.25;
        controlState.right = dx > 0.25;
        controlState.forward = dy < -0.25;
        controlState.brake = dy > 0.25;
      }
      function joyEnd(e) {
        joystickActive = false;
        joyInner.style.transform = "translate(0,0)";
        joyX = 0;
        joyY = 0;
        controlState.left = false;
        controlState.right = false;
        controlState.forward = false;
        controlState.brake = false;
      }
      joy.addEventListener("touchstart", joyStart);
      joy.addEventListener("touchmove", joyMove);
      joy.addEventListener("touchend", joyEnd);
      joy.addEventListener("mousedown", joyStart);
      window.addEventListener("mousemove", (e) => {
        if (joystickActive) joyMove(e);
      });
      window.addEventListener("mouseup", joyEnd);

      // --- Collision detection & coin collection ---
      let collected = new Set();
      function collectCoins() {
        const ppos = player.mesh.position;
        for (let i = 0; i < coinsGroup.children.length; i++) {
          if (collected.has(i)) continue;
          const coin = coinsGroup.children[i];
          const d = coin.position.distanceTo(ppos);
          if (d < 9.5) {
            collected.add(i); // animate shrink
            coin.scale.set(0.01, 0.01, 0.01);
            save.coins = (save.coins || 0) + 5;
            updateCoinsUI(); // remove from group
            setTimeout(() => {
              if (coin.parent) coinsGroup.remove(coin);
            }, 200);
          }
        }
        // obstacles collision
        for (const obs of obstaclesGroup.children) {
          const d = obs.position.distanceTo(ppos);
          if (
            d <
            12 +
              Math.max(
                obs.geometry.parameters.width || 8,
                obs.geometry.parameters.depth || 8
              )
          ) {
            player.speed *= -0.35;
            player.mesh.position.add(
              new THREE.Vector3(
                -Math.sin(player.angle) * 6,
                0,
                Math.cos(player.angle) * 6
              )
            );
          }
        }
      }

      // --- Finish detection & overlay handling ---
      const overlay = document.getElementById("levelCompleteOverlay");
      const nextLevelBtn = document.getElementById("nextLevelBtn");
      const skipTo3Btn = document.getElementById("skipTo3Btn");
      const closeOverlayBtn = document.getElementById("closeOverlayBtn");
      function checkFinish() {
        const p = player.mesh.position;
        const finish = world.finish;
        const d = p.distanceTo(finish);
        if (d < 18) {
          // level complete
          showLevelComplete();
        }
      }
      function showLevelComplete() {
        // stop player controls
        controlState.left =
          controlState.right =
          controlState.forward =
          controlState.brake =
          controlState.boost =
            false;
        overlay.style.display = "block";
        document.getElementById("completeLevel").innerText = levelIndex;
        document.getElementById("completeCoins").innerText = save.coins || 0;
      }
      nextLevelBtn.addEventListener("click", () => {
        overlay.style.display = "none";
        levelIndex = Math.min(TOTAL_LEVELS, levelIndex + 1);
        restart();
        document.getElementById("levelLabel").innerText = levelIndex;
      });
      skipTo3Btn.addEventListener("click", () => {
        overlay.style.display = "none";
        levelIndex = 3;
        restart();
        document.getElementById("levelLabel").innerText = levelIndex;
      });
      closeOverlayBtn.addEventListener("click", () => {
        overlay.style.display = "none";
      });

      // --- Physics & animation loop ---
      let last = performance.now();
      let levelStart = performance.now();
      function animate() {
        requestAnimationFrame(animate);
        const now = performance.now();
        const dt = Math.min(0.06, (now - last) / 1000);
        last = now;
        // controls to physics
        const accelBase = 0.1;
        if (controlState.forward)
          player.speed += accelBase * (controlState.boost ? 1.9 : 1);
        if (controlState.brake) player.speed -= accelBase * 1.4;
        else player.speed *= 0.995; // natural friction
        // clamp
        const maxSpeed = 4.2 + levelIndex * 0.12;
        player.speed = Math.max(-1.8, Math.min(player.speed, maxSpeed));
        const steer = 0.035 + Math.abs(player.speed) / 220;
        if (controlState.left) player.angle += steer;
        if (controlState.right) player.angle -= steer;
        // move
        const dx = Math.sin(player.angle) * player.speed;
        const dz = Math.cos(player.angle) * player.speed;
        player.mesh.position.x += dx;
        player.mesh.position.z += dz;
        player.mesh.rotation.y = player.angle;
        // rotate wheels
        if (player.mesh.userData.wheels) {
          for (const w of player.mesh.userData.wheels)
            w.rotation.x += player.speed * 0.12;
        }
        // camera
        updateCamera();
        // collect coins & collisions
        collectCoins();
        // finish check
        checkFinish();
        // render main
        renderer.render(scene, camera);
        // render minimap
        mmCamera.position.set(
          player.mesh.position.x,
          420,
          player.mesh.position.z
        );
        mmCamera.lookAt(player.mesh.position.x, 0, player.mesh.position.z);
        mmRenderer.render(scene, mmCamera);
        // update HUD
        document.getElementById("timeLabel").innerText = (
          (now - levelStart) /
          1000
        ).toFixed(2);
      }
      requestAnimationFrame(animate);

      // --- Helpers: restart / next level ---
      function restart() {
        world = generateTrack(levelIndex);
        buildPath(world.path);
        populateEntities();
        populateEnvironment();
        player.mesh.position.set(world.path[0].x - 60, 0, world.path[0].z);
        player.speed = 0;
        player.angle = 0;
        collected = new Set();
        levelStart = performance.now(); // remove any previous finishMesh
        if (world.finishMesh && world.finishMesh.parent)
          scene.remove(world.finishMesh);
        populateEntities();
        populateEnvironment();
      }
      function nextLevel() {
        levelIndex = Math.min(TOTAL_LEVELS, levelIndex + 1);
        restart();
        document.getElementById("levelLabel").innerText = levelIndex;
      }
      window.addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === "r") restart();
        if (e.key.toLowerCase() === "n") nextLevel();
      });

      // initial save and UI
      saveGame();
      document.getElementById("levelLabel").innerText = levelIndex;
      // resize
      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        mmRenderer.setSize(260, 160);
      });
    </script>
  </body>
</html>
